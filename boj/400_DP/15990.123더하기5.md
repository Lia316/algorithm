# 백준

## 15990번 :  1, 2, 3 더하기5

[문제링크](https://www.acmicpc.net/problem/15990)

정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램

(단, 같은 수를 두 번 이상 연속해서 사용하면 안 된다)


### 코드

```c++
#include <iostream>

using namespace std;

const int d = 1000000009;
int mem[100001][4];

int main() {
    ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);

    mem[1][1] = 1;
    mem[2][2] = 1;
    mem[3][1] = 1;
    mem[3][2] = 1;
    mem[3][3] = 1;

    for(int i=4; i<=100000; i++) {
        mem[i][1] = (mem[i-1][2] + mem[i-1][3]) % d;
        mem[i][2] = (mem[i-2][1] + mem[i-2][3]) % d;
        mem[i][3] = (mem[i-3][1] + mem[i-3][2]) % d;
    }

    int t, n;
    cin >> t;
    
    while(t--) {
        cin >> n;
        cout << (long(mem[n][1]) + long(mem[n][2]) + long(mem[n][3])) % d << "\n";
    }
}

```



### 풀이

* 끝이 1로 끝나는 경우, 끝이 2로 끝나는 경우, 끝이 3으로 끝나는 경우로 나눠 각각 개수를 세어준다
* `i번째`의 `끝이 1로 끝나는 경우의 수`는, `i-1번째`의 `끝이 2로 끝나는 수`와 `끝이 3으로 끝나는 수`의 합이다
* `i번째`의 `끝이 2로 끝나는 경우의 수`는, `i-2번째`의 `끝이 1로 끝나는 수`와 `끝이 3으로 끝나는 수`의 합이다

- `i번째`의 `끝이 3로 끝나는 경우의 수`는, `i-3번째`의 `끝이 1로 끝나는 수`와 `끝이 2으로 끝나는 수`의 합이다

- 이는 중복을 피하기 위함이며, i-k 번째는 k(=1, 2, 3)을 더해야하기 때문에 나온 수이다



### 주의 사항

- 범위를 주의해야한다
- int 형은 약 +- 20억의 범위를 갖기 때문에
  - `mem[i][1] = (mem[i-1][2] + mem[i-1][3]) % d;` 에서는 최대 10억 + 10억이라 문제가 없고
  - `(long(mem[n][1]) + long(mem[n][2]) + long(mem[n][3])) % d` 에서는 최대 30억이라 문제가 있다
  - 그렇기 때문에 long으로 형변환해서 나눠줘야 제대로된 값이 나온다
